# 技术需求
## 页面说明
提供三个页面

1. 主页：提供导入按钮，导入文件后，左边侧栏有一个书名列表，点击对应书名可以查看在该书中做的标记。右侧为对应的标记。且在标记右上角提供一键复制的按钮。
2. 统计页面

个人信息统计  
- 您是第N位用户
- 当前累计上传XX次
- 累计标注X本书籍，超过了XX%用户
- 当前累计标记了XX次

平台推荐
- 3条随机抽取的标注 (从数据库里随机抽取三条标注推荐给用户 并且附上书名)
- 热门阅读 书籍排行榜 即根据多少人阅读来排行(遍历book表，对应book每本书，去record_book表中检索有n条记录，即得到有n个用户阅读了这本书。进行排序得到该排行榜)
- 热门标注 书籍排行榜 即根据标记条数来排行。(同上，检索得到record_book后根据record_book_id去mark中遍历累加得到对应该本书共有多少个标记)


统计数据
- 近6月每月新增用户数 (统计user表中create_at时间)
- 近6月每月总上传次数 (统计record表中create_at时间)
- 近6月累计新增标记的书籍(统计book表中的create_at时间)

3. 关于页面：通过https://slides.com/ 做一个ppt，包括 产品介绍，使用流程，开发人员介绍。 by wilson

## 用户系统
因为不想另外增加账号系统，但是考虑到统计等需求，需要尽可能的标识用户。所以目前采用如下方案。

打开页面后首先去localstorge中获取uid，如果不存在，则前端随机生成一串32位的数字并利用localstorge存储在本地。
每次请求的时候在url中带上该uid，后端通过获取该数据标识用户。
 
`uid : 12345654321234565432123456543210`

## 文件上传
用户选择文件后，前端将文件上传给后台，并且带上UID。

考虑到前端需要解析，不如直接将前端的解析结果发给后端，以避免重复劳动。

## 前端
### 数据格式
解析出这样的数据，传给后端。
```
[
    {
        "代码之美": {
            author: "Grey Wilson",
            mark: [
                {
                    start_position: "68-69",
                    mark_time: "2017-01-06 08:59:03", // txt 文件中为 ”2016年2月10日星期三 上午9:01:52“ ，需要转格式
                    content: "正在被越来越多地使用，它们不仅被包含在用C语言开发的库中，而且还被作为脚本语言如Awk 和Perl的语法的一部分。"
                },
                {
                    start_position: "1925-1929",
                    mark_time: "2017-01-06 08:59:03", // txt 文件中为 ”2016年2月10日星期三 上午9:01:52“ ，需要转格式
                    content: "在几年以前，当时我还是一个顾问，曾经在 1 到 2 年的时间里。"
                }
            ]
        }
    }
]
```
### 功能
1. 生成uid
2. 将文件上传给后台
3. 利用 `filereader` 按以上数据格式解析文本
4. 按照书名，提供展示。
5. 一键复制功能 https://github.com/zenorocha/clipboard.js
6. 数据分析展示页面 https://github.com/highcharts/highcharts (待定)

## 后端

### 接口列表
1. 上传myclipings.txt文件接口,如果是新用户则在user表中插入一条新记录，并且在record表中插入此次上传记录
2. 前端将解析myclipings.txt后得到的数据发送给后端，后端对这个数据进行解析，并且更新book与mark。 
3. 获取统计数据 (待定)

### 数据库列表
```
user
{
    id: 1,  // 自增id对应其他3个表里的user_id
    ip: "192.168.2.1", 
    uid: 12345654321234565432123456543210, // 标识具体用户
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}

upload
{
    id: 1,
    user_id: 1, 
    date: "2017-01-06", //每次用户上传后根据日期检测当天是否有上传记录，有的话就更新次数time
    time: 1, // 上传次数 
    path: "/2017/1/7/uid" // 根据年份，月份，日来放置文件，默认同一天一个用户只上传一个文件，第二次上传覆盖第一次的文件，以用户uid为文件名
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}
mark
{
    id:1,
    book_id:1, // 对应哪本书
    user_id:1, // 此字段为冗余字段，但是为了方便统计而存在。(根据对应关系，mark索引book_id,再通过book索引user_id，这里允许冗余，方便检索)
    upload_id: 1,  // 同一个用户第二次上传同一本书，可能会出现新的标记，故record_id可以帮助解释该mark是第几次上传时就存在的。
    
    start_position: "1925-1929", // 第二次上传时，根据start_position来标识每条mark，如果存在则查询length，如果长度相同则代表无更新，反之用户可能增长了mark，则更新此条记录
    length: 32, // content的长度
    mark_time: "2017-01-06 08:59:03", 
    content: "在几年以前，当时我还是一个顾问，曾经在 1 到 2 年的时间里，似乎每个与我交谈过的 客户都非常肯定地认为在他的业务中需要一个 Web 服务解决方案。当然，虽然在我的客户中 很少有人能真正地理解这意味着什么或者为什么他需要这种架构，但由于他们总是不断地在 互联网上杂志上以及博览会上听说到 Web 服务，因此他们认为最好能搭上 Web 服务这趟车， 以免错过机会"
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}
book // 对应唯一的书籍
{
    id: 1,
    name: "代码之美",
    author: '李军',
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}
```
