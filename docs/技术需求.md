# 技术需求
## 用户系统
因为不想另外增加账号系统，但是考虑到统计等需求，需要尽可能的标识用户。所以目前采用如下方案。

打开页面后首先去localstorge中获取uid，如果不存在，则前端随机生成一串32位的数字并利用localstorge存储在本地。
每次请求的时候在url中带上该uid，后端通过获取该数据标识用户。
 
`uid : 12345654321234565432123456543210`

## 文件上传
用户选择文件后，前端将文件上传给后台，并且带上UID。

考虑到前端需要解析，不如直接将前端的解析结果发给后端，以避免重复劳动。

## 前端
### 数据格式
解析出这样的数据，传给后端。
```
[
    {
        "代码之美": {
            author: "Grey Wilson",
            mark: [
                {
                    start_position: "68-69",
                    mark_time: "2017-01-06 08:59:03", // txt 文件中为 ”2016年2月10日星期三 上午9:01:52“ ，需要转格式
                    content: "正在被越来越多地使用，它们不仅被包含在用C语言开发的库中，而且还被作为脚本语言如Awk 和Perl的语法的一部分。"
                },
                {
                    start_position: "1925-1929",
                    mark_time: "2017-01-06 08:59:03", // txt 文件中为 ”2016年2月10日星期三 上午9:01:52“ ，需要转格式
                    content: "在几年以前，当时我还是一个顾问，曾经在 1 到 2 年的时间里。"
                }
            ]
        }
    }
]
```
### 功能
1. 生成uid
2. 将文件上传给后台
3. 利用 `filereader` 按以上数据格式解析文本
4. 按照书名，提供展示。
5. 一键复制功能 https://github.com/zenorocha/clipboard.js
6. 数据分析展示页面 https://github.com/highcharts/highcharts (待定)

## 后端

### 接口列表
1. 上传myclipings.txt文件接口,如果是新用户则在user表中插入一条新记录，并且在record表中插入此次上传记录
2. 前端将解析myclipings.txt后得到的数据发送给后端，后端对这个数据进行解析，并且更新book与mark。 
3. 获取统计数据 (待定)

### 数据库列表
```
user
{
    id: 1,  // 自增id对应其他3个表里的user_id
    ip: "192.168.2.1", 
    uid: 12345654321234565432123456543210, // 标识具体用户
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}

record 
{
    id: 1,
    user_id: 1, 
    date: "2017-01-06", //每次用户上传后根据日期检测当天是否有上传记录，有的话就更新次数time
    time: 1, // 上传次数 
    path: "/2017/1/7/uid" // 根据年份，月份，日来放置文件，默认同一天一个用户只上传一个文件，第二次上传覆盖第一次的文件，以用户uid为文件名
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}
record_book 
{
    id: 1,
    user_id:1, // 每本书可能会有多个用户阅读，记为不同的书籍
    record_id:1, // 每本书有对应的record以第一次为准，每个用户可能多次上传包含同一本书标记文件，该字段生成后不更新
    name: "代码之美",  
    author: "Grey Wilson",
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
    static_book_id: 1 // 以书名为唯一标识
}
record_mark
{
    id:1,
    book_id:1, // 对应哪本书
    user_id:1, // 此字段为冗余字段，但是为了方便统计而存在。(根据对应关系，mark索引book_id,再通过book索引user_id，这里允许冗余，方便检索)
    record_id: 1,  // 同一个用户第二次上传同一本书，可能会出现新的标记，故record_id可以帮助解释该mark是第几次上传时就存在的。
    start_position: "1925-1929", // 第二次上传时，根据start_position来标识每条mark，如果存在则查询length，如果长度相同则代表无更新，反之用户可能增长了mark，则更新此条记录
    length: 32, // content的长度
    mark_time: "2017-01-06 08:59:03", 
    content: "在几年以前，当时我还是一个顾问，曾经在 1 到 2 年的时间里，似乎每个与我交谈过的 客户都非常肯定地认为在他的业务中需要一个 Web 服务解决方案。当然，虽然在我的客户中 很少有人能真正地理解这意味着什么或者为什么他需要这种架构，但由于他们总是不断地在 互联网上杂志上以及博览会上听说到 Web 服务，因此他们认为最好能搭上 Web 服务这趟车， 以免错过机会"
    create_at: "2017-01-06 08:59:03",
    update_at: "2017-01-06 08:59:03"
}
book 
{
    id: 1,
    name: "代码之美",

}
```
